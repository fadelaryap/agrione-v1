name: ğŸš€ Deploy to VPS

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: ğŸ” Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸš€ Deploy to VPS
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -o ConnectTimeout=30 \
              -o TCPKeepAlive=yes \
              ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            set -e
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Starting deployment..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Find project directory
            PROJECT_DIR=""
            if [ -d /opt/agrione/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione/agrione-v1
            elif [ -d ~/agrione-v1 ]; then
              PROJECT_DIR=~/agrione-v1
            elif [ -d /opt/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione-v1
            else
              echo "âŒ Project directory not found!"
              echo "   Please clone repository to /opt/agrione/agrione-v1, ~/agrione-v1, or /opt/agrione-v1"
              exit 1
            fi
            
            cd "$PROJECT_DIR"
            echo "ğŸ“ Project directory: $(pwd)"
            
            # Pull latest changes
            echo ""
            echo "ğŸ“¥ Pulling latest changes from GitHub..."
            git fetch origin
            
            # Get current branch or default to main
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
            if [ "$CURRENT_BRANCH" = "" ]; then
              CURRENT_BRANCH="main"
            fi
            
            # Try to checkout main or master
            if git show-ref --verify --quiet refs/remotes/origin/main; then
              git checkout -B main origin/main 2>/dev/null || git checkout main
              git reset --hard origin/main
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              git checkout -B master origin/master 2>/dev/null || git checkout master
              git reset --hard origin/master
            else
              echo "âš ï¸  No main or master branch found, using current branch"
            fi
            
            # Clean up Docker build cache only (keep running containers)
            echo ""
            echo "ğŸ§¹ Cleaning up Docker build cache (keeping running containers)..."
            docker builder prune -af || true
            
            # Get VPS IP for environment variables
            VPS_IP=$(hostname -I | awk '{print $1}')
            echo "ğŸŒ VPS IP: $VPS_IP"
            
            # Check if domain is configured (via .env or use default)
            DOMAIN="agrione.agrihub.id"  # Default domain
            if [ -f .env ] && grep -q "CORS_ORIGIN=https://" .env; then
              DOMAIN=$(grep "CORS_ORIGIN=https://" .env | cut -d'=' -f2 | sed 's|https://||')
              echo "ğŸŒ Domain detected from .env: $DOMAIN"
            else
              echo "ğŸŒ Using default domain: $DOMAIN"
            fi
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              echo "ğŸ“ Creating .env file..."
              {
                echo "POSTGRES_USER=agrione"
                echo "POSTGRES_PASSWORD=agrione123"
                echo "POSTGRES_DB=agrione_db"
                echo "JWT_SECRET=your-super-secret-jwt-key-change-in-production"
                echo "CSRF_SECRET=your-csrf-secret-key-change-in-production"
                echo "CORS_ORIGIN=https://$DOMAIN"
                echo "NEXT_PUBLIC_API_URL=https://$DOMAIN/api"
              } > .env
            else
              echo "ğŸ“ Updating .env file with domain: $DOMAIN"
              
              # Hapus semua IP address dari .env (pastikan pakai domain)
              echo "ğŸ§¹ Removing any IP addresses from .env..."
              sed -i '/103\.31\.205\.102/d' .env
              sed -i '/http:\/\/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}:/d' .env
              
              # Always use domain (HTTPS)
              CORS_ORIGIN="https://$DOMAIN"
              API_URL="https://$DOMAIN/api"
              
              if grep -q "CORS_ORIGIN=" .env; then
                sed -i "s|CORS_ORIGIN=.*|CORS_ORIGIN=$CORS_ORIGIN|" .env
              else
                echo "CORS_ORIGIN=$CORS_ORIGIN" >> .env
              fi
              
              if grep -q "NEXT_PUBLIC_API_URL=" .env; then
                sed -i "s|NEXT_PUBLIC_API_URL=.*|NEXT_PUBLIC_API_URL=$API_URL|" .env
              else
                echo "NEXT_PUBLIC_API_URL=$API_URL" >> .env
              fi
              
              # GCS Configuration (jika belum ada)
              if ! grep -q "^GCS_BUCKET_NAME=" .env; then
                echo "GCS_BUCKET_NAME=" >> .env
              fi
              if ! grep -q "^GOOGLE_CLIENT_EMAIL=" .env; then
                echo "GOOGLE_CLIENT_EMAIL=" >> .env
              fi
              if ! grep -q "^GOOGLE_PRIVATE_KEY=" .env; then
                echo "GOOGLE_PRIVATE_KEY=" >> .env
              fi
              if ! grep -q "^GOOGLE_PRIVATE_KEY_ID=" .env; then
                echo "GOOGLE_PRIVATE_KEY_ID=" >> .env
              fi
              if ! grep -q "^GOOGLE_CLIENT_ID=" .env; then
                echo "GOOGLE_CLIENT_ID=" >> .env
              fi
              
              echo "âœ… .env updated with domain configuration"
              echo "   CORS_ORIGIN=$CORS_ORIGIN"
              echo "   NEXT_PUBLIC_API_URL=$API_URL"
            fi
            
            # Use production compose file
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            echo "ğŸ“„ Using compose file: $COMPOSE_FILE"
            
            # Build containers (while old containers are still running - zero downtime)
            echo ""
            echo "ğŸ”¨ Building new container images (this may take a while)..."
            echo "   âš ï¸  Old containers are still running to prevent downtime"
            echo "   This process may take 5-10 minutes. Please wait..."
            # Use cache for faster builds and lower memory usage
            # Set DOCKER_BUILDKIT=1 for better build performance
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            # Build with cache to reduce memory usage (--no-cache causes OOM issues)
            # If you need clean build, manually run: docker builder prune -af
            docker compose -f "$COMPOSE_FILE" build || {
              echo "âš ï¸  Build process failed. Old containers are still running."
              echo "ğŸ’¡ If build fails due to cache issues, try: docker builder prune -af"
              docker compose -f "$COMPOSE_FILE" ps || true
              exit 1
            }
            
            # Rolling update: Docker Compose will update containers with new images
            # This minimizes downtime by updating containers one by one
            echo ""
            echo "ğŸ”„ Performing rolling update (zero downtime)..."
            echo "   Updating containers with new images..."
            
            # For frontend, we need to rebuild because NEXT_PUBLIC_API_URL is build-time
            # But we'll do it with --no-deps to avoid stopping other services
            docker compose -f "$COMPOSE_FILE" up -d --no-deps --build frontend || {
              echo "âš ï¸  Frontend update failed. Rolling back..."
              docker compose -f "$COMPOSE_FILE" restart frontend || true
              exit 1
            }
            
            # Update backend and other services (rolling update)
            docker compose -f "$COMPOSE_FILE" up -d --no-deps backend || {
              echo "âš ï¸  Backend update failed. Rolling back..."
              docker compose -f "$COMPOSE_FILE" restart backend || true
              exit 1
            }
            
            # Update postgres if needed (usually no changes, but ensure it's running)
            docker compose -f "$COMPOSE_FILE" up -d postgres || true
            
            # Wait a moment for services to stabilize
            echo ""
            echo "â³ Waiting for services to stabilize (5 seconds)..."
            sleep 5
            
            # Verify all containers are running
            echo ""
            echo "âœ… Verifying deployment..."
            if ! docker compose -f "$COMPOSE_FILE" ps | grep -q "Up"; then
              echo "âš ï¸  Some containers are not running. Checking status..."
              docker compose -f "$COMPOSE_FILE" ps
              exit 1
            fi
            
            # Clean up old/unused images (keep images that are still in use)
            echo ""
            echo "ğŸ§¹ Cleaning up old/unused Docker images..."
            docker image prune -f || true
            
            # Show container status
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… Deployment complete!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            docker compose -f "$COMPOSE_FILE" ps
          ENDSSH

      - name: ğŸ“Š Container Status
        run: |
          sleep 5
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -o ConnectTimeout=30 \
              ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo ""
            echo "ğŸ“Š Container Status:"
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            docker compose -f "$COMPOSE_FILE" ps
            echo ""
            echo "âœ… Deployment completed. Check logs if needed:"
            echo "   docker compose -f $COMPOSE_FILE logs backend"
            echo "   docker compose -f $COMPOSE_FILE logs frontend"
          ENDSSH
