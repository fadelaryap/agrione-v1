name: ğŸš€ Deploy to VPS

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: ğŸ” Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸš€ Deploy to VPS
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            set -e
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Starting deployment..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Find project directory
            PROJECT_DIR=""
            if [ -d /opt/agrione/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione/agrione-v1
            elif [ -d ~/agrione-v1 ]; then
              PROJECT_DIR=~/agrione-v1
            elif [ -d /opt/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione-v1
            else
              echo "âŒ Project directory not found!"
              echo "   Please clone repository to /opt/agrione/agrione-v1, ~/agrione-v1, or /opt/agrione-v1"
              exit 1
            fi
            
            cd "$PROJECT_DIR"
            echo "ğŸ“ Project directory: $(pwd)"
            
            # Pull latest changes
            echo ""
            echo "ğŸ“¥ Pulling latest changes from GitHub..."
            git fetch origin
            
            # Get current branch or default to main
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
            if [ "$CURRENT_BRANCH" = "" ]; then
              CURRENT_BRANCH="main"
            fi
            
            # Try to checkout main or master
            if git show-ref --verify --quiet refs/remotes/origin/main; then
              git checkout -B main origin/main 2>/dev/null || git checkout main
              git reset --hard origin/main
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              git checkout -B master origin/master 2>/dev/null || git checkout master
              git reset --hard origin/master
            else
              echo "âš ï¸  No main or master branch found, using current branch"
            fi
            
            # Stop existing containers
            echo ""
            echo "ğŸ›‘ Stopping existing containers..."
            # Try both compose files
            docker compose -f docker-compose.prod.yml down || true
            docker compose down || true
            
            # Get VPS IP for environment variables
            VPS_IP=$(hostname -I | awk '{print $1}')
            echo "ğŸŒ VPS IP: $VPS_IP"
            
            # Check if domain is configured (via .env or use default)
            DOMAIN="agrione.agrihub.id"  # Default domain
            if [ -f .env ] && grep -q "CORS_ORIGIN=https://" .env; then
              DOMAIN=$(grep "CORS_ORIGIN=https://" .env | cut -d'=' -f2 | sed 's|https://||')
              echo "ğŸŒ Domain detected from .env: $DOMAIN"
            else
              echo "ğŸŒ Using default domain: $DOMAIN"
            fi
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              echo "ğŸ“ Creating .env file..."
              {
                echo "POSTGRES_USER=agrione"
                echo "POSTGRES_PASSWORD=agrione123"
                echo "POSTGRES_DB=agrione_db"
                echo "JWT_SECRET=your-super-secret-jwt-key-change-in-production"
                echo "CSRF_SECRET=your-csrf-secret-key-change-in-production"
                echo "CORS_ORIGIN=https://$DOMAIN"
                echo "NEXT_PUBLIC_API_URL=https://$DOMAIN/api"
              } > .env
            else
              echo "ğŸ“ Updating .env file with domain: $DOMAIN"
              
              # Hapus semua IP address dari .env (pastikan pakai domain)
              echo "ğŸ§¹ Removing any IP addresses from .env..."
              sed -i '/103\.31\.205\.102/d' .env
              sed -i '/http:\/\/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}:/d' .env
              
              # Always use domain (HTTPS)
              CORS_ORIGIN="https://$DOMAIN"
              API_URL="https://$DOMAIN/api"
              
              if grep -q "CORS_ORIGIN=" .env; then
                sed -i "s|CORS_ORIGIN=.*|CORS_ORIGIN=$CORS_ORIGIN|" .env
              else
                echo "CORS_ORIGIN=$CORS_ORIGIN" >> .env
              fi
              
              if grep -q "NEXT_PUBLIC_API_URL=" .env; then
                sed -i "s|NEXT_PUBLIC_API_URL=.*|NEXT_PUBLIC_API_URL=$API_URL|" .env
              else
                echo "NEXT_PUBLIC_API_URL=$API_URL" >> .env
              fi
              
              # GCS Configuration for frontend (jika belum ada)
              if ! grep -q "^GCS_BUCKET_NAME=" .env; then
                echo "GCS_BUCKET_NAME=" >> .env
              fi
              if ! grep -q "^GCS_CREDENTIALS_JSON=" .env; then
                echo "GCS_CREDENTIALS_JSON=" >> .env
              fi
              
              echo "âœ… .env updated with domain configuration"
              echo "   CORS_ORIGIN=$CORS_ORIGIN"
              echo "   NEXT_PUBLIC_API_URL=$API_URL"
            fi
            
            # Use production compose file
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            echo "ğŸ“„ Using compose file: $COMPOSE_FILE"
            
            # Build containers
            echo ""
            echo "ğŸ”¨ Building containers (this may take a while)..."
            # Use cache for faster builds (remove --no-cache unless needed)
            docker compose -f "$COMPOSE_FILE" build
            
            # Rebuild frontend to pick up NEXT_PUBLIC_API_URL (build-time variable)
            echo ""
            echo "ğŸ”„ Rebuilding frontend with updated NEXT_PUBLIC_API_URL..."
            docker compose -f "$COMPOSE_FILE" up -d --build frontend
            
            # Start/restart other containers
            echo ""
            echo "ğŸš€ Starting containers..."
            docker compose -f "$COMPOSE_FILE" up -d
            docker compose -f "$COMPOSE_FILE" restart backend
            
            # Wait for services to be ready
            echo ""
            echo "â³ Waiting for services to start (15 seconds)..."
            sleep 15
            
            # Clean up old images
            echo ""
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker image prune -f
            
            # Show container status
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… Deployment complete!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            docker compose ps
          ENDSSH

      - name: ğŸ¥ Health Check
        run: |
          sleep 5
          ssh -o StrictHostKeyChecking=no ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo ""
            echo "ğŸ¥ Running health checks..."
            echo ""
            
            # Check containers
            echo "ğŸ“Š Container Status:"
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            docker compose -f "$COMPOSE_FILE" ps
            echo ""
            
            # Check backend
            echo "ğŸ” Checking backend (http://localhost:8000/api/health)..."
            if curl -f http://localhost:8000/api/health > /dev/null 2>&1; then
              echo "âœ… Backend is healthy"
            else
              echo "âš ï¸  Backend health check failed (may need more time to start)"
              echo "   Check logs with: docker compose -f $COMPOSE_FILE logs backend"
            fi
            
            # Check frontend
            echo ""
            echo "ğŸ” Checking frontend (http://localhost:3000)..."
            if curl -f http://localhost:3000 > /dev/null 2>&1; then
              echo "âœ… Frontend is healthy"
            else
              echo "âš ï¸  Frontend health check failed (may need more time to start)"
              echo "   Check logs with: docker compose -f $COMPOSE_FILE logs frontend"
            fi
          ENDSSH
