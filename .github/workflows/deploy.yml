name: ğŸš€ Deploy to VPS

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:  # Allow manual trigger

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”‘ Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}

      - name: ğŸ” Add VPS to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts

      - name: ğŸš€ Deploy to VPS
        run: |
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -o ConnectTimeout=30 \
              -o TCPKeepAlive=yes \
              ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            set -e
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸš€ Starting deployment..."
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            
            # Find project directory
            PROJECT_DIR=""
            if [ -d /opt/agrione/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione/agrione-v1
            elif [ -d ~/agrione-v1 ]; then
              PROJECT_DIR=~/agrione-v1
            elif [ -d /opt/agrione-v1 ]; then
              PROJECT_DIR=/opt/agrione-v1
            else
              echo "âŒ Project directory not found!"
              echo "   Please clone repository to /opt/agrione/agrione-v1, ~/agrione-v1, or /opt/agrione-v1"
              exit 1
            fi
            
            cd "$PROJECT_DIR"
            echo "ğŸ“ Project directory: $(pwd)"
            
            # Pull latest changes
            echo ""
            echo "ğŸ“¥ Pulling latest changes from GitHub..."
            git fetch origin
            
            # Get current branch or default to main
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
            if [ "$CURRENT_BRANCH" = "" ]; then
              CURRENT_BRANCH="main"
            fi
            
            # Try to checkout main or master
            if git show-ref --verify --quiet refs/remotes/origin/main; then
              git checkout -B main origin/main 2>/dev/null || git checkout main
              git reset --hard origin/main
            elif git show-ref --verify --quiet refs/remotes/origin/master; then
              git checkout -B master origin/master 2>/dev/null || git checkout master
              git reset --hard origin/master
            else
              echo "âš ï¸  No main or master branch found, using current branch"
            fi
            
            # Clean up Docker before starting (fix disk space and cache issues)
            echo ""
            echo "ğŸ§¹ Cleaning up Docker (images, containers, build cache)..."
            docker system prune -af --volumes || true
            docker builder prune -af || true
            
            # Stop existing containers
            echo ""
            echo "ğŸ›‘ Stopping existing containers..."
            # Try both compose files (ignore errors if file doesn't exist)
            if [ -f docker-compose.prod.yml ]; then
              docker compose -f docker-compose.prod.yml down || true
            fi
            if [ -f docker-compose.yml ]; then
              docker compose down || true
            fi
            
            # Get VPS IP for environment variables
            VPS_IP=$(hostname -I | awk '{print $1}')
            echo "ğŸŒ VPS IP: $VPS_IP"
            
            # Check if domain is configured (via .env or use default)
            DOMAIN="agrione.agrihub.id"  # Default domain
            if [ -f .env ] && grep -q "CORS_ORIGIN=https://" .env; then
              DOMAIN=$(grep "CORS_ORIGIN=https://" .env | cut -d'=' -f2 | sed 's|https://||')
              echo "ğŸŒ Domain detected from .env: $DOMAIN"
            else
              echo "ğŸŒ Using default domain: $DOMAIN"
            fi
            
            # Create .env file if it doesn't exist
            if [ ! -f .env ]; then
              echo "ğŸ“ Creating .env file..."
              {
                echo "POSTGRES_USER=agrione"
                echo "POSTGRES_PASSWORD=agrione123"
                echo "POSTGRES_DB=agrione_db"
                echo "JWT_SECRET=your-super-secret-jwt-key-change-in-production"
                echo "CSRF_SECRET=your-csrf-secret-key-change-in-production"
                echo "CORS_ORIGIN=https://$DOMAIN"
                echo "NEXT_PUBLIC_API_URL=https://$DOMAIN/api"
              } > .env
            else
              echo "ğŸ“ Updating .env file with domain: $DOMAIN"
              
              # Hapus semua IP address dari .env (pastikan pakai domain)
              echo "ğŸ§¹ Removing any IP addresses from .env..."
              sed -i '/103\.31\.205\.102/d' .env
              sed -i '/http:\/\/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}:/d' .env
              
              # Always use domain (HTTPS)
              CORS_ORIGIN="https://$DOMAIN"
              API_URL="https://$DOMAIN/api"
              
              if grep -q "CORS_ORIGIN=" .env; then
                sed -i "s|CORS_ORIGIN=.*|CORS_ORIGIN=$CORS_ORIGIN|" .env
              else
                echo "CORS_ORIGIN=$CORS_ORIGIN" >> .env
              fi
              
              if grep -q "NEXT_PUBLIC_API_URL=" .env; then
                sed -i "s|NEXT_PUBLIC_API_URL=.*|NEXT_PUBLIC_API_URL=$API_URL|" .env
              else
                echo "NEXT_PUBLIC_API_URL=$API_URL" >> .env
              fi
              
              # GCS Configuration (jika belum ada)
              if ! grep -q "^GCS_BUCKET_NAME=" .env; then
                echo "GCS_BUCKET_NAME=" >> .env
              fi
              if ! grep -q "^GOOGLE_CLIENT_EMAIL=" .env; then
                echo "GOOGLE_CLIENT_EMAIL=" >> .env
              fi
              if ! grep -q "^GOOGLE_PRIVATE_KEY=" .env; then
                echo "GOOGLE_PRIVATE_KEY=" >> .env
              fi
              if ! grep -q "^GOOGLE_PRIVATE_KEY_ID=" .env; then
                echo "GOOGLE_PRIVATE_KEY_ID=" >> .env
              fi
              if ! grep -q "^GOOGLE_CLIENT_ID=" .env; then
                echo "GOOGLE_CLIENT_ID=" >> .env
              fi
              
              echo "âœ… .env updated with domain configuration"
              echo "   CORS_ORIGIN=$CORS_ORIGIN"
              echo "   NEXT_PUBLIC_API_URL=$API_URL"
            fi
            
            # Use production compose file
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            echo "ğŸ“„ Using compose file: $COMPOSE_FILE"
            
            # Clean up Docker build cache before building (fix snapshot errors)
            echo ""
            echo "ğŸ§¹ Cleaning up Docker build cache before build..."
            docker builder prune -af || true
            
            # Build containers
            echo ""
            echo "ğŸ”¨ Building containers (this may take a while)..."
            echo "   This process may take 5-10 minutes. Please wait..."
            # Use --no-cache to avoid snapshot errors from corrupt cache
            # Set DOCKER_BUILDKIT=1 for better build performance
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            docker compose -f "$COMPOSE_FILE" build --no-cache || {
              echo "âš ï¸  Build process failed. Checking status..."
              docker compose -f "$COMPOSE_FILE" ps || true
              exit 1
            }
            
            # Rebuild frontend to pick up NEXT_PUBLIC_API_URL (build-time variable)
            echo ""
            echo "ğŸ”„ Rebuilding frontend with updated NEXT_PUBLIC_API_URL..."
            docker compose -f "$COMPOSE_FILE" up -d --build frontend
            
            # Start/restart other containers
            echo ""
            echo "ğŸš€ Starting containers..."
            docker compose -f "$COMPOSE_FILE" up -d
            docker compose -f "$COMPOSE_FILE" restart backend
            
            # Wait for services to be ready
            echo ""
            echo "â³ Waiting for services to start (15 seconds)..."
            sleep 15
            
            # Clean up old images
            echo ""
            echo "ğŸ§¹ Cleaning up old Docker images..."
            docker image prune -f
            
            # Show container status
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âœ… Deployment complete!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo ""
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            docker compose -f "$COMPOSE_FILE" ps
          ENDSSH

      - name: ğŸ“Š Container Status
        run: |
          sleep 5
          ssh -o StrictHostKeyChecking=no \
              -o ServerAliveInterval=60 \
              -o ServerAliveCountMax=10 \
              -o ConnectTimeout=30 \
              ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'ENDSSH'
            echo ""
            echo "ğŸ“Š Container Status:"
            COMPOSE_FILE="docker-compose.prod.yml"
            if [ ! -f "$COMPOSE_FILE" ]; then
              COMPOSE_FILE="docker-compose.yml"
            fi
            docker compose -f "$COMPOSE_FILE" ps
            echo ""
            echo "âœ… Deployment completed. Check logs if needed:"
            echo "   docker compose -f $COMPOSE_FILE logs backend"
            echo "   docker compose -f $COMPOSE_FILE logs frontend"
          ENDSSH
